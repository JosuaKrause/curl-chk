#!/bin/bash

read -r -d '' PYTHON_LIST <<'EOF'
from __future__ import print_function
import hashlib
print("\n".join(hashlib.algorithms_guaranteed))
EOF

read -r -d '' PYTHON_HASH <<'EOF'
from __future__ import print_function
import hashlib
import sys
m = hashlib.new(sys.argv[1])
with open(sys.argv[2], 'rb') as f:
  m.update(f.read())
print(m.hexdigest())
EOF

REAL_CURL='curl'
if [ ! -z $NO_PYTHON ] && [ $NO_PYTHON != 0 ]; then
  NO_PYTHON="NO_PYTHON"
else
  NO_PYTHON=
  DIGEST_LIST=`echo "${PYTHON_LIST}" | /usr/bin/env python - 2>/dev/null`
  if [ $? != 0 ]; then
    NO_PYTHON="NO_PYTHON"
  fi
fi
if [ ! -z $NO_PYTHON ]; then
  DIGEST_LIST="md5"
fi
# DIGEST_LIST="md5" # TODO we don't *actually* support multiple digests yet
USE_MD5SUM=
if [ `command -v md5 2>/dev/null 1>&2; echo $?` != 0 ]; then
  USE_MD5SUM="USE_MD5SUM"
fi

url_pattern='[#\?](.*\&)*md5=([0-9a-fA-F]+)'

usage() {
  $REAL_CURL "$@"
  local x=$?
  cat <<'EOF'
     --digest-list   Lists all available checksum algorithms and exits
     --quiet         Indicate checksum results only in status code (42 if fail)
This wrapper of curl will verify the contents of URLs using the md5 sum of their
content. The expected md5 sum can either be passed with --digest or can be part
of the URLs via the following regex:
EOF
  echo "  /${url_pattern}/"
  echo "Explicit md5 sums via --digest take higher precedence."
  return $x
}

quiet=
auto_file=

cur_url=
cur_out=
cur_md5=
list_out=()
list_md5=()

temp_file=
make_temp_file() {
  if [ ! -z "${temp_file}" ]; then
    return 1
  fi
  local prefix=`basename $0`
  temp_file=`mktemp "${prefix}.XXXXXX"`
  if [ $? -ne 0 ]; then
    echo "Internal error: Could not create temp file" 1>&2
    exit 97
  fi
  trap 'rm -rf -- "${temp_file}" 2>/dev/null' EXIT
  return 0
}

check_file() {
  local output_file="$1"; shift
  local md5_sum="$1"; shift
  local md5_cmp=
  local ret=0
  if [ -f "${output_file}" ]; then
    if [ ! -z $NO_PYTHON ]; then
      if [ -z $USE_MD5SUM ]; then
        md5_cmp=`md5 -q "${output_file}"`
      else
        md5_cmp=`md5sum "${output_file}" | sed -E 's/^([0-9a-fA-F]+)($|[^0-9a-fA-F].*$)/\1/'`
      fi
    else
      local digest="md5"
      md5_cmp=`echo "${PYTHON_HASH}" | /usr/bin/env python - "${digest}" "${output_file}"`
      if [ $? != 0 ]; then
        echo "Internal error: Error while digesting" 1>&2
        exit 96
      fi
    fi
    local ok="OK"
    if [ "${md5_sum}" != "${md5_cmp}" ]; then
      ret=42
      ok="FAILED"
    fi
    if [ -z "${quiet}" ]; then
      local name="${output_file}"
      if [ "${output_file}" == "${temp_file}" ]; then
        name="STDOUT"
      fi
      echo "${name}: ${ok} ${md5_cmp}" 1>&2
    fi
  else
    echo "Internal error: Invalid output file '${output_file}'" 1>&2
    exit 98
  fi
  return $ret
}

check_list() {
  local ret=0
  local total="${#list_out[*]}"
  local no_match=0
  local ix=0
  while [ "${ix}" -lt "${total}" ]; do
    check_file "${list_out[$ix]}" "${list_md5[$ix]}"
    local x=$?
    if [ $x != 0 ]; then
      ret=$x
      no_match=$((no_match+1))
    fi
    ix=$((ix+1))
  done
  if [ $ret != 0 ] && [ -z "${quiet}" ]; then
    echo "WARNING: ${no_match} of ${total} computed checksums did NOT match" 1>&2
  fi
  return $ret
}

add_to_list() {
  if [ ! -z "${cur_url}" ]; then
    if [ -z "${cur_md5}" ]; then
      local pattern="^.*${url_pattern}[^\/]*\$"
      cur_md5=`echo "${cur_url}" | grep -E "${pattern}" | sed -E "s/${pattern}/\2/"`
    fi
    if [ ! -z "${auto_file}" ] && [ -z "${cur_out}" ]; then
      local pattern="\/([^/#]+)(#|\$)"
      cur_out=`echo "${cur_url}" | grep -oE "${pattern}" | sed -E "s/${pattern}/\1/"`
    fi
  fi
  if [ ! -z "${cur_md5}" ]; then
    if [ ! -z "${cur_out}" ]; then
      list_out+=("${cur_out}")
      list_md5+=("${cur_md5}")
    else
      make_temp_file
      list_out+=("${temp_file}")
      list_md5+=("${cur_md5}")
    fi
  fi
  cur_url=
  cur_out=
  cur_md5=
}

set_cur() {
  local field="$1"; shift
  local value="$1"; shift
  case "${field}" in
    url)
      if [ ! -z "${cur_url}" ]; then
        add_to_list
      fi
      cur_url="${value}"
      ;;
    out)
      if [ ! -z "${cur_out}" ]; then
        add_to_list
      fi
      cur_out="${value}"
      ;;
    md5)
      if [ ! -z "${cur_md5}" ]; then
        add_to_list
      fi
      cur_md5="${value}"
      ;;
    *)
      echo "Internal error: Illegal field ${field}" 1>&2
      exit 99
      ;;
  esac
}

args=()
print_usage=
while [ $# -gt 0 ]; do
  no_preserve_arg=
  remove_fragment=
  case "$1" in
  -h|--help) # flag for usage
    print_usage="print_usage"
    ;;
  --quiet) # flag for quiet mode
    quiet="quiet"
    no_preserve_arg="no_preserve_arg"
    ;;
  --digest-list)
    echo "${DIGEST_LIST}"
    exit 0
    ;;
  --digest) # explicit digest argument
    shift
    set_cur md5 `echo "$1" | sed "s/^md5=//"`
    no_preserve_arg="no_preserve_arg"
    ;;
  --url) # explicit URL argument
    args+=("$1")
    shift
    set_cur url "$1"
    remove_fragment="remove_fragment"
    ;;
  -o|--output) # explicit output argument
    args+=("$1")
    shift
    set_cur out "$1"
    ;;
  -O|--remote-name|--remote-name-all) # automatic file name inference
    auto_file="auto_file"
    ;;
  -*) # arbitrary arguments
    ;;
  *) # url
    set_cur url "$1"
    remove_fragment="remove_fragment"
    ;;
  esac
  arg="$1"
  if [ ! -z "${remove_fragment}" ]; then
    # remove the fragment part to ensure the correct name when using -O
    arg=`echo "${arg}" | sed -E "s/#.*$//"`
  fi
  if [ -z "$no_preserve_arg" ]; then
    args+=("$arg")
  fi
  shift
done

# clear current variables
add_to_list

# only show usage?
if [ ! -z "${print_usage}" ]; then
  usage "${args[@]}"
  exit $?
fi

# execute the original curl
if [ -z "${temp_file}" ]; then
  $REAL_CURL "${args[@]}"
else
  $REAL_CURL "${args[@]}" > "${temp_file}"
fi

if [ $? != 0 ]; then
  exit $?
fi

# check md5 for files
check_list
check_result=$?
if [ ! -z "${temp_file}" ] && [ $check_result == 0 ]; then
  cat "${temp_file}"
fi
exit $check_result
