#!/bin/bash

read -r -d '' PYTHON_LIST <<'EOF'
from __future__ import print_function
import hashlib
print("\n".join(hashlib.algorithms_available))
EOF

read -r -d '' PYTHON_HASH <<'EOF'
from __future__ import print_function
import hashlib
import sys
m = hashlib.new(sys.argv[1])
with open(sys.argv[2], 'rb') as f:
  m.update(f.read())
print(m.hexdigest())
EOF

if [ -z $REAL_CURL ]; then
  REAL_CURL='curl'
fi
if [ ! -z $NO_PYTHON ] && [ $NO_PYTHON != 0 ]; then
  NO_PYTHON="NO_PYTHON"
else
  NO_PYTHON=
  DIGEST_LIST=(`echo "${PYTHON_LIST}" | /usr/bin/env python - 2>/dev/null`)
  if [ $? != 0 ]; then
    NO_PYTHON="NO_PYTHON"
  fi
fi
if [ ! -z $NO_PYTHON ]; then
  DIGEST_LIST=("md5")
fi
USE_MD5SUM=
if [ `command -v md5 2>/dev/null 1>&2; echo $?` != 0 ]; then
  USE_MD5SUM="USE_MD5SUM"
fi

join() {
  local IFS="$1"; shift
  echo "$*"
}

digest_pattern=`join "|" "${DIGEST_LIST[@]}"`
url_pattern="[#\?](.*\&)*(${digest_pattern})=([0-9a-fA-F]+)"

usage() {
  $REAL_CURL "$@"
  local x=$?
  cat <<'EOF'
     --digest-list   Lists all available checksum algorithms and exits
     --quiet         Indicate checksum results only in status code (42 if fail)
This wrapper of curl will verify the contents of URLs using a checksum of their
content. The expected sum can either be passed with --digest or can be part
of the URLs via the following regex:
EOF
  echo "  /${url_pattern}/"
  echo "Explicit sums via --digest take higher precedence."
  return $x
}

quiet=
auto_file=

cur_url=
cur_out=
cur_sum=
cur_digest=
list_out=()
list_sum=()
list_digest=()

temp_file=
make_temp_file() {
  if [ ! -z "${temp_file}" ]; then
    return 1
  fi
  local prefix=`basename $0`
  temp_file=`mktemp "${prefix}.XXXXXX"`
  if [ $? -ne 0 ]; then
    echo "Internal error: Could not create temp file" 1>&2
    exit 97
  fi
  trap 'rm -rf -- "${temp_file}" 2>/dev/null' EXIT
  return 0
}

check_file() {
  local output_file="$1"; shift
  local checksum="$1"; shift
  local digest="$1"; shift
  local checksum_cmp=
  local ret=0
  if [ -f "${output_file}" ]; then
    if [ ! -z $NO_PYTHON ]; then
      if [ "${digest}" != "md5" ]; then
        echo "Internal error: Unsupported digest '${digest}'"
        exit 95
      fi
      if [ -z $USE_MD5SUM ]; then
        checksum_cmp=`md5 -q "${output_file}"`
      else
        checksum_cmp=`md5sum "${output_file}" | sed -E 's/^([0-9a-fA-F]+)($|[^0-9a-fA-F].*$)/\1/'`
      fi
    else
      checksum_cmp=`echo "${PYTHON_HASH}" | /usr/bin/env python - "${digest}" "${output_file}"`
      if [ $? != 0 ]; then
        echo "Internal error: Error while digesting" 1>&2
        exit 96
      fi
    fi
    local ok="OK"
    if [ "${checksum}" != "${checksum_cmp}" ]; then
      ret=42
      ok="FAILED"
    fi
    if [ -z "${quiet}" ]; then
      local name="${output_file}"
      if [ "${output_file}" == "${temp_file}" ]; then
        name="STDOUT"
      fi
      echo "${name}: ${ok} ${checksum_cmp}" 1>&2
    fi
  else
    echo "Internal error: Invalid output file '${output_file}'" 1>&2
    exit 98
  fi
  return $ret
}

check_list() {
  local ret=0
  local total="${#list_out[*]}"
  local no_match=0
  local ix=0
  while [ "${ix}" -lt "${total}" ]; do
    check_file "${list_out[$ix]}" "${list_sum[$ix]}" "${list_digest[$ix]}"
    local x=$?
    if [ $x != 0 ]; then
      ret=$x
      no_match=$((no_match+1))
    fi
    ix=$((ix+1))
  done
  if [ $ret != 0 ] && [ -z "${quiet}" ]; then
    echo "WARNING: ${no_match} of ${total} computed checksums did NOT match" 1>&2
  fi
  return $ret
}

add_to_list() {
  if [ ! -z "${cur_url}" ]; then
    if [ -z "${cur_sum}" ]; then
      local pattern="^.*${url_pattern}[^\/]*\$"
      cur_sum=`echo "${cur_url}" | grep -E "${pattern}" | sed -E "s/${pattern}/\3/"`
      cur_digest=`echo "${cur_url}" | grep -E "${pattern}" | sed -E "s/${pattern}/\2/"`
    fi
    if [ ! -z "${auto_file}" ] && [ -z "${cur_out}" ]; then
      local pattern="\/([^/#]+)(#|\$)"
      cur_out=`echo "${cur_url}" | grep -oE "${pattern}" | sed -E "s/${pattern}/\1/"`
    fi
  fi
  if [ ! -z "${cur_sum}" ]; then
    if [ ! -z "${cur_out}" ]; then
      list_out+=("${cur_out}")
    else
      make_temp_file
      list_out+=("${temp_file}")
    fi
    list_sum+=("${cur_sum}")
    list_digest+=("${cur_digest}")
  fi
  cur_url=
  cur_out=
  cur_sum=
  cur_digest=
}

set_cur() {
  local field="$1"; shift
  local value="$1"; shift
  local digest="$1"; shift
  case "${field}" in
    url)
      if [ ! -z "${cur_url}" ]; then
        add_to_list
      fi
      cur_url="${value}"
      ;;
    out)
      if [ ! -z "${cur_out}" ]; then
        add_to_list
      fi
      cur_out="${value}"
      ;;
    digest)
      if [ ! -z "${cur_sum}" ]; then
        add_to_list
      fi
      cur_sum="${value}"
      if [ -z `echo "${digest}" | grep -E "${digest_pattern}"` ]; then
        local prefix=`echo "${digest}" | sed -E "s/^([^=]*)=.*$/\1/"`
        echo "Unknown digest '${prefix}'! Use '$0 --digest-list' for a list of available digests." 1>&2
        exit 94
      fi
      cur_digest="${digest}"
      ;;
    *)
      echo "Internal error: Illegal field ${field}" 1>&2
      exit 99
      ;;
  esac
}

args=()
print_usage=
while [ $# -gt 0 ]; do
  no_preserve_arg=
  remove_fragment=
  case "$1" in
  -h|--help) # flag for usage
    print_usage="print_usage"
    ;;
  --quiet) # flag for quiet mode
    quiet="quiet"
    no_preserve_arg="no_preserve_arg"
    ;;
  --digest-list)
    printf "%s\n" "${DIGEST_LIST[@]}"
    exit 0
    ;;
  --digest) # explicit digest argument
    shift
    set_cur digest `echo "$1" | sed -E "s/^(${digest_pattern})=//"` `echo "$1" | sed -E "s/^(${digest_pattern})=.*$/\1/"`
    no_preserve_arg="no_preserve_arg"
    ;;
  --url) # explicit URL argument
    args+=("$1")
    shift
    set_cur url "$1" ""
    remove_fragment="remove_fragment"
    ;;
  -o|--output) # explicit output argument
    args+=("$1")
    shift
    set_cur out "$1" ""
    ;;
  -O|--remote-name|--remote-name-all) # automatic file name inference
    auto_file="auto_file"
    ;;
  -*) # arbitrary arguments
    ;;
  *) # url
    set_cur url "$1" ""
    remove_fragment="remove_fragment"
    ;;
  esac
  arg="$1"
  if [ ! -z "${remove_fragment}" ]; then
    # remove the fragment part to ensure the correct name when using -O
    arg=`echo "${arg}" | sed -E "s/#.*$//"`
  fi
  if [ -z "$no_preserve_arg" ]; then
    args+=("$arg")
  fi
  shift
done

# clear current variables
add_to_list

# only show usage?
if [ ! -z "${print_usage}" ]; then
  usage "${args[@]}"
  exit $?
fi

# execute the original curl
if [ -z "${temp_file}" ]; then
  $REAL_CURL "${args[@]}"
else
  $REAL_CURL "${args[@]}" > "${temp_file}"
fi

if [ $? != 0 ]; then
  exit $?
fi

# check md5 for files
check_list
check_result=$?
if [ ! -z "${temp_file}" ] && [ $check_result == 0 ]; then
  cat "${temp_file}"
fi
exit $check_result
